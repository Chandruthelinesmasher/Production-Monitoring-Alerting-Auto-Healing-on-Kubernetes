name: SRE AKS CI/CD Pipeline

on:
  push:
    branches: ["main"]
  pull_request:
    branches: ["main"]
  workflow_dispatch:

env:
  TF_VERSION: "1.6.6"
  IMAGE_NAME: k8s-sre-monitoring-app
  LOCATION: eastus2
  RESOURCE_GROUP: rg-sre-monitoring-dev
  # Backend configuration - storage created automatically by pipeline
  BACKEND_RESOURCE_GROUP: rg-terraform-state
  BACKEND_STORAGE_ACCOUNT: tfstatesremonitoring
  BACKEND_CONTAINER: tfstate
  BACKEND_KEY: sre-monitoring-dev.tfstate

jobs:
  terraform:
    name: Terraform Infrastructure
    runs-on: ubuntu-latest
    
    outputs:
      acr_login_server: ${{ steps.tfout.outputs.acr }}
      acr_name: ${{ steps.tfout.outputs.acr_name }}
      aks_cluster_name: ${{ steps.tfout.outputs.aks }}
      resource_group: ${{ steps.tfout.outputs.rg }}
      backend_configured: ${{ steps.backend.outputs.configured }}
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Azure Login (Service Principal)
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false

      - name: Create Backend Storage (if not exists)
        id: backend
        run: |
          echo "üîß Setting up Terraform backend storage..."
          
          # Create resource group for state (idempotent)
          echo "Creating resource group: ${{ env.BACKEND_RESOURCE_GROUP }}"
          az group create \
            --name ${{ env.BACKEND_RESOURCE_GROUP }} \
            --location ${{ env.LOCATION }} \
            --tags environment=shared purpose=terraform-state \
            || true
          
          # Check if storage account exists
          echo "Checking storage account: ${{ env.BACKEND_STORAGE_ACCOUNT }}"
          if az storage account show --name ${{ env.BACKEND_STORAGE_ACCOUNT }} --resource-group ${{ env.BACKEND_RESOURCE_GROUP }} &>/dev/null; then
            echo "‚úÖ Storage account already exists: ${{ env.BACKEND_STORAGE_ACCOUNT }}"
          else
            echo "üì¶ Creating storage account: ${{ env.BACKEND_STORAGE_ACCOUNT }}"
            az storage account create \
              --name ${{ env.BACKEND_STORAGE_ACCOUNT }} \
              --resource-group ${{ env.BACKEND_RESOURCE_GROUP }} \
              --location ${{ env.LOCATION }} \
              --sku Standard_LRS \
              --encryption-services blob \
              --https-only true \
              --min-tls-version TLS1_2 \
              --allow-blob-public-access false
            
            # Wait for storage account to be ready
            echo "Waiting for storage account to be ready..."
            sleep 10
            echo "‚úÖ Storage account created"
          fi
          
          # Get storage account key
          echo "Retrieving storage account key..."
          ACCOUNT_KEY=$(az storage account keys list \
            --resource-group ${{ env.BACKEND_RESOURCE_GROUP }} \
            --account-name ${{ env.BACKEND_STORAGE_ACCOUNT }} \
            --query '[0].value' -o tsv)
          
          if [ -z "$ACCOUNT_KEY" ]; then
            echo "‚ùå Failed to retrieve storage account key"
            exit 1
          fi
          
          echo "‚úÖ Storage account key retrieved"
          
          # Check if container exists
          echo "Checking container: ${{ env.BACKEND_CONTAINER }}"
          CONTAINER_EXISTS=$(az storage container exists \
            --name ${{ env.BACKEND_CONTAINER }} \
            --account-name ${{ env.BACKEND_STORAGE_ACCOUNT }} \
            --account-key ${ACCOUNT_KEY} \
            --query exists -o tsv)
          
          if [ "$CONTAINER_EXISTS" = "true" ]; then
            echo "‚úÖ Container already exists: ${{ env.BACKEND_CONTAINER }}"
          else
            echo "üì¶ Creating container: ${{ env.BACKEND_CONTAINER }}"
            az storage container create \
              --name ${{ env.BACKEND_CONTAINER }} \
              --account-name ${{ env.BACKEND_STORAGE_ACCOUNT }} \
              --account-key ${ACCOUNT_KEY} \
              --auth-mode key
            
            # Verify container was created
            sleep 5
            VERIFY=$(az storage container exists \
              --name ${{ env.BACKEND_CONTAINER }} \
              --account-name ${{ env.BACKEND_STORAGE_ACCOUNT }} \
              --account-key ${ACCOUNT_KEY} \
              --query exists -o tsv)
            
            if [ "$VERIFY" = "true" ]; then
              echo "‚úÖ Container created successfully"
            else
              echo "‚ùå Failed to create container"
              exit 1
            fi
          fi
          
          echo "configured=true" >> $GITHUB_OUTPUT
          echo "storage_account=${{ env.BACKEND_STORAGE_ACCOUNT }}" >> $GITHUB_OUTPUT
          
          echo ""
          echo "‚úÖ Backend storage ready!"
          echo "   Resource Group: ${{ env.BACKEND_RESOURCE_GROUP }}"
          echo "   Storage Account: ${{ env.BACKEND_STORAGE_ACCOUNT }}"
          echo "   Container: ${{ env.BACKEND_CONTAINER }}"

      - name: Terraform Format Check
        working-directory: terraform
        run: terraform fmt -check -recursive
        continue-on-error: true

      - name: Terraform Init with Backend
        run: |
          cd terraform
          
          echo "üîß Initializing Terraform with Azure backend..."
          
          # Get storage account key
          ACCOUNT_KEY=$(az storage account keys list \
            --resource-group ${{ env.BACKEND_RESOURCE_GROUP }} \
            --account-name ${{ env.BACKEND_STORAGE_ACCOUNT }} \
            --query '[0].value' -o tsv)
          
          if [ -z "$ACCOUNT_KEY" ]; then
            echo "‚ùå Failed to retrieve storage account key"
            exit 1
          fi
          
          # Verify container exists before init
          echo "Verifying backend container exists..."
          CONTAINER_EXISTS=$(az storage container exists \
            --name ${{ env.BACKEND_CONTAINER }} \
            --account-name ${{ env.BACKEND_STORAGE_ACCOUNT }} \
            --account-key ${ACCOUNT_KEY} \
            --query exists -o tsv)
          
          if [ "$CONTAINER_EXISTS" != "true" ]; then
            echo "‚ùå Container ${{ env.BACKEND_CONTAINER }} does not exist!"
            echo "Creating container now..."
            az storage container create \
              --name ${{ env.BACKEND_CONTAINER }} \
              --account-name ${{ env.BACKEND_STORAGE_ACCOUNT }} \
              --account-key ${ACCOUNT_KEY} \
              --auth-mode key
            sleep 5
          fi
          
          echo "‚úÖ Backend container verified"
          
          # Initialize with Azure backend
          terraform init -upgrade \
            -backend-config="resource_group_name=${{ env.BACKEND_RESOURCE_GROUP }}" \
            -backend-config="storage_account_name=${{ env.BACKEND_STORAGE_ACCOUNT }}" \
            -backend-config="container_name=${{ env.BACKEND_CONTAINER }}" \
            -backend-config="key=${{ env.BACKEND_KEY }}" \
            -backend-config="access_key=${ACCOUNT_KEY}"
          
          echo "‚úÖ Terraform initialized with remote backend"
          echo "üìç State location: ${{ env.BACKEND_STORAGE_ACCOUNT }}/${{ env.BACKEND_CONTAINER }}/${{ env.BACKEND_KEY }}"

      - name: Terraform Validate
        run: |
          cd terraform
          terraform validate

      - name: Register Required Azure Resource Providers
        run: |
          echo "Registering required Azure Resource Providers..."
          
          az provider register --namespace Microsoft.ContainerService --wait
          az provider register --namespace Microsoft.ContainerRegistry --wait
          az provider register --namespace Microsoft.Network --wait
          az provider register --namespace Microsoft.Compute --wait
          az provider register --namespace Microsoft.Storage --wait
          
          echo "‚úÖ All required resource providers registered"

      - name: Get Available Kubernetes Versions
        id: k8s_versions
        run: |
          echo "Getting available Kubernetes versions for ${{ env.LOCATION }}..."
          
          # Get full detailed output
          az aks get-versions --location ${{ env.LOCATION }} --output table
          
          echo ""
          echo "=== Extracting ALL patch versions ==="
          
          # Get full JSON to inspect all patch versions
          az aks get-versions --location ${{ env.LOCATION }} -o json > /tmp/k8s_full.json
          
          # Display the structure
          echo "Available versions structure:"
          cat /tmp/k8s_full.json | jq -r '.values[] | select(.isPreview == null) | {version: .version, patches: .patchVersions | keys}'
          
          echo ""
          echo "=== Looking for oldest supported patch versions ==="
          
          # Extract ALL patch versions (oldest patches are typically non-LTS)
          ALL_PATCHES=$(cat /tmp/k8s_full.json | jq -r '
            .values[] | 
            select(.isPreview == null) | 
            .patchVersions | 
            keys[]
          ' | sort -V)
          
          echo "All available patch versions:"
          echo "$ALL_PATCHES"
          
          # Store for next step
          echo "$ALL_PATCHES" > /tmp/k8s_patches.txt

      - name: Terraform Plan
        id: plan
        run: |
          cd terraform
          
          echo "Determining best Kubernetes version..."
          
          # Read available patch versions
          ALL_PATCHES=$(cat /tmp/k8s_patches.txt)
          
          echo "All patches available:"
          echo "$ALL_PATCHES"
          
          # Strategy 1: Try to find oldest 1.28.x (most likely to be non-LTS)
          K8S_VERSION=$(echo "$ALL_PATCHES" | grep "^1\.28\." | head -n 1)
          
          if [ -n "$K8S_VERSION" ]; then
            echo "‚úÖ Selected oldest 1.28 patch: $K8S_VERSION"
          else
            # Strategy 2: Try oldest 1.29.x
            K8S_VERSION=$(echo "$ALL_PATCHES" | grep "^1\.29\." | head -n 1)
            if [ -n "$K8S_VERSION" ]; then
              echo "‚ö†Ô∏è Selected oldest 1.29 patch: $K8S_VERSION (may be LTS)"
            else
              # Strategy 3: Try oldest 1.27.x
              K8S_VERSION=$(echo "$ALL_PATCHES" | grep "^1\.27\." | head -n 1)
              if [ -n "$K8S_VERSION" ]; then
                echo "‚ö†Ô∏è Selected oldest 1.27 patch: $K8S_VERSION"
              else
                # Last resort: get oldest overall non-1.31 version
                K8S_VERSION=$(echo "$ALL_PATCHES" | grep -v "^1\.31\." | head -n 1)
                echo "‚ö†Ô∏è Fallback to oldest available: $K8S_VERSION"
              fi
            fi
          fi
          
          if [ -z "$K8S_VERSION" ]; then
            echo "‚ùå ERROR: No suitable Kubernetes version found!"
            echo "Available versions:"
            echo "$ALL_PATCHES"
            exit 1
          fi
          
          echo ""
          echo "Final selected version: $K8S_VERSION"
          echo "k8s_version=${K8S_VERSION}" >> $GITHUB_OUTPUT
          
          # Run plan
          terraform plan \
            -var="location=${{ env.LOCATION }}" \
            -var="environment=dev" \
            -var="resource_group_name=${{ env.RESOURCE_GROUP }}" \
            -var="acr_name=acrsremonitoringdev" \
            -var="acr_sku=Basic" \
            -var="aks_cluster_name=aks-sre-monitoring-dev" \
            -var="aks_dns_prefix=aks-sre-dev" \
            -var="kubernetes_version=$K8S_VERSION" \
            -out=tfplan \
            -detailed-exitcode || PLAN_EXIT=$?
          
          # Capture plan status (0=no changes, 1=error, 2=changes)
          if [ "${PLAN_EXIT:-0}" -eq 2 ]; then
            echo "has_changes=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Plan created - changes detected"
          elif [ "${PLAN_EXIT:-0}" -eq 0 ]; then
            echo "has_changes=false" >> $GITHUB_OUTPUT
            echo "‚ÑπÔ∏è Plan created - no changes needed"
          else
            echo "‚ùå Plan failed with exit code ${PLAN_EXIT}"
            exit 1
          fi

      - name: Terraform Apply
        if: |
          (github.event_name == 'push' && github.ref == 'refs/heads/main') ||
          (github.event_name == 'workflow_dispatch')
        run: |
          cd terraform
          
          echo "üöÄ Applying Terraform changes..."
          terraform apply -auto-approve tfplan
          
          echo "‚úÖ Infrastructure provisioned successfully"

      - name: Verify Infrastructure Created
        if: |
          (github.event_name == 'push' && github.ref == 'refs/heads/main') ||
          (github.event_name == 'workflow_dispatch')
        run: |
          echo "Verifying infrastructure creation..."
          
          # Check resource group
          if az group show --name ${{ env.RESOURCE_GROUP }} &>/dev/null; then
            echo "‚úÖ Resource group exists: ${{ env.RESOURCE_GROUP }}"
          else
            echo "‚ùå Resource group not found!"
            exit 1
          fi
          
          # Check ACR
          if az acr show --name acrsremonitoringdev --resource-group ${{ env.RESOURCE_GROUP }} &>/dev/null; then
            echo "‚úÖ ACR exists: acrsremonitoringdev"
          else
            echo "‚ùå ACR not found!"
            exit 1
          fi
          
          # Check AKS
          if az aks show --name aks-sre-monitoring-dev --resource-group ${{ env.RESOURCE_GROUP }} &>/dev/null; then
            echo "‚úÖ AKS cluster exists: aks-sre-monitoring-dev"
          else
            echo "‚ùå AKS cluster not found!"
            exit 1
          fi
          
          echo "‚úÖ All infrastructure verified successfully"

      - name: Export Terraform Outputs
        id: tfout
        if: |
          (github.event_name == 'push' && github.ref == 'refs/heads/main') ||
          (github.event_name == 'workflow_dispatch')
        run: |
          cd terraform
          echo "acr=$(terraform output -raw acr_login_server)" >> $GITHUB_OUTPUT
          echo "acr_name=$(terraform output -raw acr_name)" >> $GITHUB_OUTPUT
          echo "aks=$(terraform output -raw aks_cluster_name)" >> $GITHUB_OUTPUT
          echo "rg=$(terraform output -raw resource_group_name)" >> $GITHUB_OUTPUT
          
          echo "üìã Infrastructure Outputs:"
          echo "  ACR: $(terraform output -raw acr_login_server)"
          echo "  AKS: $(terraform output -raw aks_cluster_name)"
          echo "  RG: $(terraform output -raw resource_group_name)"

  build-and-push:
    name: Build & Push Docker Image
    needs: terraform
    runs-on: ubuntu-latest
    if: |
      (github.ref == 'refs/heads/main' && github.event_name == 'push') ||
      github.event_name == 'workflow_dispatch'
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Login to Azure Container Registry
        run: |
          # Use ACR name, not login server
          az acr login --name ${{ needs.terraform.outputs.acr_name }}
          echo "‚úÖ Logged into ACR: ${{ needs.terraform.outputs.acr_name }}"

      - name: Build Docker Image
        working-directory: app
        run: |
          echo "üî® Building Docker image..."
          docker build \
            -t ${{ needs.terraform.outputs.acr_login_server }}/${{ env.IMAGE_NAME }}:${{ github.sha }} \
            -t ${{ needs.terraform.outputs.acr_login_server }}/${{ env.IMAGE_NAME }}:latest \
            .
          echo "‚úÖ Image built successfully"

      - name: Push Docker Image
        run: |
          echo "üì§ Pushing images to ACR..."
          docker push ${{ needs.terraform.outputs.acr_login_server }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
          docker push ${{ needs.terraform.outputs.acr_login_server }}/${{ env.IMAGE_NAME }}:latest
          echo "‚úÖ Images pushed successfully"

      - name: Verify Image in ACR
        run: |
          az acr repository show \
            --name ${{ needs.terraform.outputs.acr_name }} \
            --repository ${{ env.IMAGE_NAME }} \
            --query "name"
          echo "‚úÖ Image verified in ACR"

  deploy-app:
    name: Deploy Application to AKS
    needs: [terraform, build-and-push]
    runs-on: ubuntu-latest
    if: |
      (github.ref == 'refs/heads/main' && github.event_name == 'push') ||
      github.event_name == 'workflow_dispatch'
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Get AKS Credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ needs.terraform.outputs.resource_group }} \
            --name ${{ needs.terraform.outputs.aks_cluster_name }} \
            --overwrite-existing
          
          # Verify connection
          kubectl cluster-info
          echo "‚úÖ Connected to AKS cluster"

      - name: Create App Namespace
        run: kubectl create namespace app --dry-run=client -o yaml | kubectl apply -f -

      - name: Update Image in Deployment
        run: |
          sed -i "s|IMAGE_PLACEHOLDER|${{ needs.terraform.outputs.acr_login_server }}/${{ env.IMAGE_NAME }}:${{ github.sha }}|g" k8s/app/deployment.yaml

      - name: Deploy Application
        run: |
          kubectl apply -f k8s/app/deployment.yaml -n app
          kubectl apply -f k8s/app/service.yaml -n app
          kubectl apply -f k8s/app/hpa.yaml -n app
          echo "‚úÖ Application manifests applied"

      - name: Wait for Rollout
        run: |
          kubectl rollout status deployment/sre-app -n app --timeout=5m
          echo "‚úÖ Deployment rolled out successfully"

      - name: Verify Deployment
        run: |
          echo "üìã Deployment Status:"
          kubectl get pods -n app
          kubectl get svc -n app
          echo "‚úÖ Application deployed successfully"

  deploy-monitoring:
    name: Deploy Monitoring Stack
    needs: [terraform, deploy-app]
    runs-on: ubuntu-latest
    if: |
      (github.ref == 'refs/heads/main' && github.event_name == 'push') ||
      github.event_name == 'workflow_dispatch'
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Get AKS Credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ needs.terraform.outputs.resource_group }} \
            --name ${{ needs.terraform.outputs.aks_cluster_name }} \
            --overwrite-existing

      - name: Add Helm Repositories
        run: |
          helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
          helm repo add grafana https://grafana.github.io/helm-charts
          helm repo update
          echo "‚úÖ Helm repositories added"

      - name: Create Monitoring Namespace
        run: kubectl create namespace monitoring --dry-run=client -o yaml | kubectl apply -f -

      - name: Install/Upgrade Prometheus Stack
        run: |
          helm upgrade --install monitoring prometheus-community/kube-prometheus-stack \
            -n monitoring \
            --create-namespace \
            --set prometheus.prometheusSpec.serviceMonitorSelectorNilUsesHelmValues=false \
            --set grafana.adminPassword=admin123 \
            --timeout 10m \
            --wait
          echo "‚úÖ Monitoring stack deployed"

      - name: Verify Monitoring Stack
        run: |
          echo "üìã Monitoring Status:"
          kubectl get pods -n monitoring
          kubectl get svc -n monitoring
          echo "‚úÖ Monitoring stack verified"

      - name: Get Grafana Admin Password
        run: |
          echo "üîê Grafana Credentials:"
          echo "  Username: admin"
          echo -n "  Password: "
          kubectl get secret --namespace monitoring monitoring-grafana -o jsonpath="{.data.admin-password}" | base64 --decode
          echo ""

  smoke-test:
    name: Smoke Tests
    needs: [deploy-app, deploy-monitoring]
    runs-on: ubuntu-latest
    if: |
      (github.ref == 'refs/heads/main' && github.event_name == 'push') ||
      github.event_name == 'workflow_dispatch'
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Get AKS Credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ needs.terraform.outputs.resource_group }} \
            --name ${{ needs.terraform.outputs.aks_cluster_name }} \
            --overwrite-existing

      - name: Test Application Health
        run: |
          echo "üß™ Testing application health endpoint..."
          kubectl run curl-test --image=curlimages/curl:latest --rm -i --restart=Never -n app -- \
            curl -f http://sre-app-service:3000/health || exit 1
          echo "‚úÖ Health check passed"
        timeout-minutes: 2

      - name: Test Metrics Endpoint
        run: |
          echo "üß™ Testing metrics endpoint..."
          kubectl run curl-test --image=curlimages/curl:latest --rm -i --restart=Never -n app -- \
            curl -f http://sre-app-service:3000/metrics || exit 1
          echo "‚úÖ Metrics check passed"
        timeout-minutes: 2

      - name: Verify Prometheus
        run: |
          kubectl get pods -n monitoring -l app.kubernetes.io/name=prometheus
          echo "‚úÖ Prometheus is running"

      - name: Verify Grafana
        run: |
          kubectl get pods -n monitoring -l app.kubernetes.io/name=grafana
          echo "‚úÖ Grafana is running"

      - name: Display Service Endpoints
        run: |
          echo "üìã Service Endpoints:"
          echo ""
          echo "=== Application Services ==="
          kubectl get svc -n app
          echo ""
          echo "=== Monitoring Services ==="
          kubectl get svc -n monitoring
          echo ""
          echo "=== External IP (if LoadBalancer) ==="
          kubectl get svc sre-app-service -n app -o jsonpath='{.status.loadBalancer.ingress[0].ip}' || echo "No external IP yet"

  notify:
    name: Notify Deployment Status
    needs: [smoke-test]
    runs-on: ubuntu-latest
    if: always()
    
    steps:
      - name: Deployment Success
        if: needs.smoke-test.result == 'success'
        run: |
          echo "‚úÖ SRE AKS Deployment Successful!"
          echo "Commit: ${{ github.sha }}"
          echo "Branch: ${{ github.ref }}"
          echo "Environment: Production"

      - name: Deployment Failure
        if: needs.smoke-test.result != 'success'
        run: |
          echo "‚ùå SRE AKS Deployment Failed!"
          echo "Commit: ${{ github.sha }}"
          echo "Branch: ${{ github.ref }}"
          echo "Please check the workflow logs for details"
          exit 1